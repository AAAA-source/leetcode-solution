# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
I mainly reference from : https://www.youtube.com/watch?v=LvdJTQ-BYtw&t=12s

We first difine :
n = string length 
z = string's zeros 
m = minimum operation times 

Because we should flip m times , the total flip is m*k times. 
For each '0' , it should be flip odd times ; each '1' should be flip even time. Due to this obersavation , we know that mk - z should be even.

We then consider two cases : 
1. Case 1 : m is even , then mk - z is even only when z is even. Also , for every '0' at most be flip m - 1 times (if any '0' flip m + 1 or above , then we can just minus one time of k-flip) , every '1' at most be flip m times , so the equation is : 
$$ (m-1)*z + m * (n - z) >= mk $$
can simplify as : 
$$ m >= \lceil \frac{z}{n-k} \rceil  $$

The minimum of m is that flip z zeros one times , so 
$$m >= \lceil \frac{z}{k} \rceil$$

That is , for m is odd , m will be $m >= max(\lceil \frac{z}{k} \rceil , \lceil \frac{z}{n-k} \rceil)$

2. Case 2 : m is odd , then mk - z is even only when z and k have same duality. Also , every '0' at most be flip m times , every '1' at most be flip m - 1 times. So the equation is 
$$ m * z + (m-1) * (n-z) >= mk $$
Can simplify as : 
$$ m >= \lceil  \frac{n-z}{n-k} \rceil$$
m also holds $m >= \lceil \frac{z}{k} \rceil$ , 

That is , for m is even , m will be $max(\lceil \frac{z}{k} \rceil , \lceil \frac{n-z}{n-k} \rceil)$

For those ones who want to know why m can work , you can take a look at "Gale-Ryser theorem"

# Complexity
- Time complexity: $O(1)$
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
We just need some arithmetic operations , which take constant time. 

- Space complexity: $O(1)$
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
We only need constant space for some variables.

# Code
```cpp []
class Solution {
public:
    int minOperations(string s, int k) {
        int zerocount = 0 ;
        for(auto &i : s)
            if (i == '0')
                zerocount++ ;

        int n = s.size() ;

        // first handle special case 
        if (zerocount == 0)
            return 0 ;
        if ( k == n )
            return (zerocount == n)? 1 : -1 ;

        int ans = INT_MAX ;
        
        
        // m is odd 
        if ( zerocount % 2 == 0 ) {
            int m = max( (zerocount + k - 1) / k , (zerocount + n - k - 1) / (n-k)) ;
            ans = (m % 2 == 0)? m : m + 1 ; // align to odd 
        }
        
        // m is even 
        if (zerocount % 2 == k % 2) {
            int m = max( (zerocount + k - 1) / k , (n - zerocount + n - k - 1) / (n-k)) ;
            ans = min(ans , ((m % 2 == 1)? m : m + 1) ) ; // align to even
        }

        return (ans == INT_MAX)? -1 : ans ;
    }
};
```
