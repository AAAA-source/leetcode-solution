# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
To make the array balanced, the maximum element should not exceed k times the minimum element. This means if we fix the minimum value, we need to find the longest subarray where the condition holds. 

The answer will be the total number of elements minus the size of this longest valid subarray.

# Approach
<!-- Describe your approach to solving the problem. -->
1. Sort the array so we can easily check the ratio between maximum and minimum.  
2. Use a two-pointer sliding window:  
   - Move the right pointer `r` to expand the window.  
   - If the condition `nums[r] <= nums[l] * k` is violated, move the left pointer `l` forward.  
3. Track the maximum window length `(r - l + 1)` that satisfies the condition.  
4. The minimum removals will be the total length minus this maximum window size.
# Complexity
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
- **Time complexity:** \(O(n log n)\) due to sorting.  
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
- **Space complexity:** \(O(1)\), since only pointers and variables are used.  

# Code
```python3 []
class Solution:
    def minRemoval(self, nums: List[int], k: int) -> int:
        nums.sort()
        ans = len(nums)
        l = 0
        for r in range(len(nums)):
            while nums[r] > nums[l] * k:
                l += 1
            ans = min(ans, len(nums) - (r-l+1))
        # print(ans)
        return ans
```
