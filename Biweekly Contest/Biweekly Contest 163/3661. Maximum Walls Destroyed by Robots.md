# 3661. Maximum Walls Destroyed by Robots
# **Intuition**
Each robot can choose to attack left or right. We need to find the combination that maximizes the union of all attack intervals while ensuring robots don't attack each other.

# **Approach**
1. **Sort and preprocess**: Sort robots by position and walls by location. Remove duplicate walls.

2. **Calculate attack intervals**: For each robot at position `x` with distance `d`:
   * Left attack: `[max(x-d, left_neighbor+1), x]`
   * Right attack: `[x, min(x+d, right_neighbor-1)]`
   * Boundaries prevent robots from attacking each other.

3. **Handle overlaps**: Calculate overlapping walls between adjacent robots' intervals using binary search for fast interval counting.

4. **Dynamic Programming**: 
   * `dp_left`: max walls when current robot attacks left
   * `dp_right`: max walls when current robot attacks right
   * Transition considers all combinations and subtracts overlapping walls using union formula: |A ∪ B| = |A| + |B| - |A ∩ B|

# **Complexity**
* Time complexity: O(n log n + w log w + n log w) - Sorting robots/walls + binary search for interval counting
* Space complexity: O(n + w) - DP arrays and preprocessing storage


# 中文題解 3661. Maximum Walls Destroyed by Robots
https://leetcode.com/problems/maximum-walls-destroyed-by-robots/solutions/7117460/clean-python-solution-binary-search-dp/

## 問題描述
有 n 台機器人，每台機器人位於 `robots[i]` 位置，攻擊距離為 `distance[i]`。每台機器人可以選擇向左或向右攻擊，攻擊範圍是一個連續區間。
**目標**: 求所有機器人攻擊區間的聯集能覆蓋的最大牆數量。

## 解題思路

### 問題分析
每台機器人有兩個選擇（向左或向右攻擊），我們需要找出使所有攻擊區間聯集覆蓋牆數最多的組合。

### 核心挑戰
1. **攻擊約束處理**: 機器人不能攻擊到其他機器人
2. **區間聯集計算**: 需要高效計算多個區間的聯集大小
3. **選擇組合優化**: 每台機器人的選擇會影響整體結果

## 算法詳解

### 步驟 1: 預處理階段
```python
# 牆位置去重並排序，便於後續二分搜索
walls = sorted(set(walls))

# 機器人按位置排序，距離信息要一起保持對應關係
bots = sorted(zip(robots, distance))
```

**為什麼要排序？**
- 牆排序：使用二分搜索快速計算區間內牆數量
- 機器人排序：只有相鄰機器人的攻擊區間才可能重疊

### 步驟 2: 計算攻擊區間
對於位置在 `x`，攻擊距離為 `d` 的機器人：

**向左攻擊區間**: `[max(x-d, left_boundary+1), x]`
**向右攻擊區間**: `[x, min(x+d, right_boundary-1)]`

```python
for i, (pos, dist) in enumerate(bots):
    left_boundary = bots[i-1][0] + 1 if i > 0 else float('-inf')
    right_boundary = bots[i+1][0] - 1 if i < n-1 else float('inf')
    
    # 確保不會攻擊到相鄰機器人
    left_intervals.append((max(pos - dist, left_boundary), pos))
    right_intervals.append((pos, min(pos + dist, right_boundary)))
```

**邊界處理的重要性**:
- `left_boundary`: 防止攻擊到左邊的機器人
- `right_boundary`: 防止攻擊到右邊的機器人
- 使用 `+1` 和 `-1` 確保不包含鄰居機器人的位置

### 步驟 3: 高效計算區間內牆數量
使用二分搜索在 O(log w) 時間內計算閉區間 `[start, end]` 內的牆數量：

```python
def count_walls(start: int, end: int) -> int:
    if start > end:
        return 0
    return bisect_right(walls, end) - bisect_left(walls, start)
```

**二分搜索原理**:
- `bisect_left(walls, start)`: 找到第一個 ≥ start 的牆的索引
- `bisect_right(walls, end)`: 找到第一個 > end 的牆的索引
- 兩者相減就是區間內牆的數量

### 步驟 4: 處理重疊區間
相鄰機器人的攻擊區間可能重疊，使用聯集公式處理：
**|A ∪ B| = |A| + |B| - |A ∩ B|**

```python
def get_overlap(interval1: tuple, interval2: tuple) -> int:
    start = max(interval1[0], interval2[0])
    end = min(interval1[1], interval2[1])
    return count_walls(start, end) if start <= end else 0
```

**重疊情況分析**:
- 第i台機器人選左攻擊 ∩ 第i-1台機器人選右攻擊
- 第i台機器人選右攻擊 ∩ 第i-1台機器人選左攻擊

### 步驟 5: 動態規劃求解
**狀態定義**:
- `dp_left[i]`: 處理到第i台機器人，且第i台選擇左攻擊時的最大牆數
- `dp_right[i]`: 處理到第i台機器人，且第i台選擇右攻擊時的最大牆數

**轉移方程**:
```python
# 當前機器人選擇左攻擊
new_left = max(
    dp_left + left_counts[i],      # 前一台也選左：無重疊
    dp_right + left_counts[i] - overlap_left_with_prev_right
)

# 當前機器人選擇右攻擊  
new_right = max(
    dp_right + right_counts[i],    # 前一台也選右：無重疊
    dp_left + right_counts[i] - overlap_right_with_prev_left  
)
```

**狀態轉移邏輯**:
1. **無重疊情況**: 前後兩台機器人選擇同方向攻擊，區間不重疊
2. **有重疊情況**: 前後兩台機器人選擇不同方向，需要扣除重疊部分

## 時間複雜度分析

### 詳細複雜度分解
- **牆去重排序**: O(w log w)，w為牆的數量
- **機器人排序**: O(n log n)，n為機器人數量  
- **計算攻擊區間**: O(n)
- **計算每個區間牆數**: O(n log w)，每次二分搜索O(log w)
- **計算重疊**: O(n log w)
- **DP轉移**: O(n)

**總時間複雜度**: O(n log n + w log w + n log w)
**空間複雜度**: O(n + w)



# Code
```python3 []
class Solution:
    def maxWalls(self, robots: List[int], distance: List[int], walls: List[int]) -> int:
        # Preprocess: deduplicate walls and sort robots by position
        walls = sorted(set(walls))
        bots = sorted(zip(robots, distance))
        n = len(bots)
        
        if n == 0 or not walls:
            return 0
        
        # Calculate attack intervals for each robot
        left_intervals = []
        right_intervals = []
        
        for i, (pos, dist) in enumerate(bots):
            left_boundary = bots[i-1][0] + 1 if i > 0 else float('-inf')
            right_boundary = bots[i+1][0] - 1 if i < n-1 else float('inf')
            
            # Left attack interval: [max(pos-dist, left_boundary), pos]
            left_intervals.append((max(pos - dist, left_boundary), pos))
            
            # Right attack interval: [pos, min(pos+dist, right_boundary)]
            right_intervals.append((pos, min(pos + dist, right_boundary)))
        
        def count_walls(start: int, end: int) -> int:
            if start > end:
                return 0
            return bisect_right(walls, end) - bisect_left(walls, start)
        
        def get_overlap(interval1: tuple, interval2: tuple) -> int:
            start = max(interval1[0], interval2[0])
            end = min(interval1[1], interval2[1])
            return count_walls(start, end) if start <= end else 0
        
        # Calculate walls count for each interval
        left_counts = [count_walls(start, end) for start, end in left_intervals]
        right_counts = [count_walls(start, end) for start, end in right_intervals]
        
        # Dynamic programming: choose left or right for each robot
        dp_left = left_counts[0]
        dp_right = right_counts[0]
        
        for i in range(1, n):
            # Current robot chooses left
            new_left = max(
                dp_left + left_counts[i],  # Previous also chose left
                dp_right + left_counts[i] - get_overlap(left_intervals[i], right_intervals[i-1])
            )
            
            # Current robot chooses right
            new_right = max(
                dp_right + right_counts[i],  # Previous also chose right
                dp_left + right_counts[i] - get_overlap(right_intervals[i], left_intervals[i-1])
            )
            
            dp_left, dp_right = new_left, new_right
        
        return max(dp_left, dp_right)
```
