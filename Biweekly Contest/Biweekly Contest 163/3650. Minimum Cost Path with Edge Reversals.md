# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
Because each edge's weight >= 0 , so we can ensure that the shortest will only pass each node at most one time. In this case , we can freely using reverse edge with double weights. 

We just need to first build the edge-map of each node (include normal edges and reverse edges) , and use dijkstra's algorithm to find out the shortest path.


# Approach
<!-- Describe your approach to solving the problem. -->

First using 2D array to record all edge with reverse edges have double weight. Then using priority queue and array to implement dijkstra's algorithm.


# Complexity
- Time complexity: $O(mlogn)$
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
We need O(m) time to build edge-map and O(mlogn) time to find out the shortest map.

- Space complexity: $O(m + n)$
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
we need O(m + n) space for priority queue

# Code
```cpp []
class Solution {
public:
    int minCost(int n, vector<vector<int>>& edges) {
        vector<vector<pair<int , int>>> totaledges(n) ;

        // insert all edges and reverse edges with double weights
        for(auto &e : edges) {
            totaledges[e[0]].push_back({e[1] , e[2]}) ;
            totaledges[e[1]].push_back( {e[0] , 2 * e[2]}) ;
        }


        // doing dijkstra's algorithm 
        priority_queue<pair<int , int> , vector<pair<int , int>> , greater<pair<int , int>>> pq ;

        // insert start point 
        pq.push({0 , 0}) ;

        // record distance for each node 
        vector<int> distances(n , INT_MAX) ;
        distances[0] = 0 ;
        
        while ( !pq.empty() ) {
            // choose the nearest point 
            auto p = pq.top() ;
            pq.pop() ;
            int node = p.first ;
            int nowdistance = p.second ;

            for(auto &e : totaledges[node]) {
                int destination = e.first ;
                int weight = e.second ;

                if ( nowdistance + weight < distances[destination] ) {
                    // find a new shortest path 
                    distances[destination] = nowdistance + weight ;
                    pq.push({destination , distances[destination]}) ;
                }
            }
            

        }

        return (distances[n - 1] == INT_MAX)? -1 : distances[n - 1] ;
    }
};
```
