# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
The problem requires finding two numbers whose binary representations share no common set bits, and maximizing their product.  
A brute-force approach would check all pairs `O(n^2)`, but that's too slow for larger inputs.  
Instead, we can treat each number as a **bitmask**, and use DP on masks to quickly query the largest possible number compatible with a given mask's complement.
# Approach
<!-- Describe your approach to solving the problem. -->
1. Compute the maximum number `max_val` to determine the required bit-width `B`.  
2. Let `N = 1 << B`, and build a DP array `dp` of size `N`.  
   - Initialize `dp[x] = x` for every number `x` in `nums`.  
3. Run a **submask DP**:  
   - For each bit `b` from `0` to `B-1`,  
   - For each mask in `[0, N)`,  
   - If `mask` has bit `b`, then update  
     ```
     dp[mask] = max(dp[mask], dp[mask ^ (1 << b)]);
     ```
   - This ensures `dp[mask]` stores the maximum value among all submasks of `mask`.  
4. For each number `x` in `nums`:  
   - Compute its complement mask `cm = (~x) & (N-1)`.  
   - Since `dp[cm]` is the maximum value among all submasks of `cm`,  
     it guarantees no overlap with `x`.  
   - Update answer: `ans = max(ans, 1LL * x * dp[cm])`.  
# Complexity
- Time complexity: $$O(n + \text{max}(nums))$$
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

- Space complexity: $$O(\text{max}(nums))$$
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

# Code
```cpp []
class Solution {
public:
    long long maxProduct(vector<int>& nums) {
        int max_val = *max_element(nums.begin(), nums.end());
        int B = 32 - __builtin_clz(max_val);
        int N = 1ull << B;                                 
        int FULL = N - 1;

        vector<int> dp(N, 0);
        for (int x : nums) dp[x] = max(dp[x], x);

        for (int b = 0; b < B; ++b) {
            for (int mask = 0; mask < N; ++mask) {
                if (mask & (1 << b)) {
                    dp[mask] = max(dp[mask], dp[mask ^ (1 << b)]);
                }
            }
        }

        long long ans = 0;
        for (int x : nums) {
            int cm = (~x) & FULL; 
            ans = max(ans, 1LL * x * dp[cm]);               
        }
        return ans;
    }
};
```
