# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
We must break n into exactly k positive integers whose product is n, and we want the smallest possible difference between the largest and smallest numbers in that list.
Because n ≤ 10 ⁵, every number has < 128 factors. By exploring factors only (not all numbers) and forcing the list to be **non-decreasing**, we keep the search tree tiny—brute-force DFS is fast enough.
# Approach
<!-- Describe your approach to solving the problem. -->
1.	State Definition
    - depth: how many factors are already fixed.
    - start: the minimum value the next factor may take (to stay non-decreasing).
    - rem: the product still missing (n ÷ current product).
2.	DFS
    - If only one slot remains (depth == k-1), place rem directly, check validity, and update the best answer.
    - Otherwise, iterate through every factor i ≥ start up to √rem. For each valid i, recurse on (depth+1, i, rem // i).
3.	Global Best
    - Track the best (max − min) and its factor list as object attributes (self.best_diff, self.best_split).
# Complexity
**- Time complexity: O(C(n,k))**
Bounded by the number of factor combinations of n; in practice < 10 ms for worst cases, roughly O(number of factors combinations)
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

**- Space complexity: O(k)**
Recursion depth ≤ k and a path array of length k, so O(k) (with k ≤ 8 for n ≤ 10 ⁵)
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

# Code
```python3 []
class Solution:
    def minDifference(self, n: int, k: int) -> List[int]:
        # best result so far
        self.best_diff: float = float("inf")
        self.best_split: Optional[List[int]] = None

        def dfs(depth: int, start: int, rem: int, path: List[int]) -> None:
            # last slot → fill with rem and evaluate
            if depth == k - 1:
                if rem >= start: 
                    cand = path + [rem]
                    diff = max(cand) - min(cand)
                    if diff < self.best_diff:
                        self.best_diff, self.best_split = diff, cand
                return

            # try every factor of rem that is ≥ start
            i = start
            while i * i <= rem:
                if rem % i == 0:
                    dfs(depth + 1, i, rem // i, path + [i])
                i += 1

        dfs(0, 1, n, [])
        return self.best_split or [n]
```
