# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
We can just use simple BFS to slove the problem because we can treat all jumps are edges with same weight.
So there are two kinds of jump : 
1. jump to i + 1 , i - 1 
2. if nums[i] is prime , jump to its multiples

There is a tricky that we should put prime table in global , and it will just fill table one time during all testcases.

# Approach
<!-- Describe your approach to solving the problem. -->
We first fill the prime table with sieve of Eratosthenes. And using 
```
if ( isprime.empty() )
    fill_prime() ;
```
to sure that the table will only be filled one time.

After that , we will record the appear locations for each number and store in a hash map.

Finished the preprocessing , we now can do the BFS will a queue. When insert the edge for prime jumps , we should use the hash map of locations to help us. And using a hash set to record the prime after used, next time we won't do the same jumps.


# Complexity
- Time complexity: $O(mlog(log(m)) + n)$
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
The m stand for the maxvalue = 1e6 , and we need O(m log(log(m))) for building the prime table. After that , we need O(n) for BFS 

- Space complexity: O(n)
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
We need O(n) space for hash map , hash set and the queue.

# Code
```cpp []
vector<int> isprime ;
class Solution {
public:
    void fill_prime(void) {
        isprime = vector<int>(1000001 , 1) ;
        isprime[0] = isprime[1] = 0 ;
        
        for(int i = 2 ; i <= 1000000 ; i++) {
            if ( isprime[i] == 0 )
                continue ;
            for(int j = i + i ; j <= 1000000 ; j += i) 
                isprime[j] = 0 ;
        }
    }

    int minJumps(vector<int>& nums) {
        int n = nums.size() ;
        int maxvalue = *max_element(nums.begin() , nums.end()) ;

        // record element appearance 
        unordered_map<int , vector<int>> locations(n) ;
        for(int i = 0 ; i < n ;i++) {
            locations[nums[i]].push_back(i) ;
        }

        // build prime table 
        if ( isprime.empty() )
            fill_prime() ;

        vector<int> distances(n , INT_MAX) ;
        queue<pair<int , int>> q ; // store {index , distance}
        q.push( {0 , 0} ) ;
        distances[0] = 0 ;

        unordered_set<int> used ;
        while (!q.empty()) {
            if ( distances[n-1] != INT_MAX )
                break ;
            int index = q.front().first ;
            int distance = q.front().second ;
            q.pop() ;
            //printf("now see {%d , %d}\n" , nums[index] , distance);

            // move to last element 
            if ( index != 0 && distances[index - 1] == INT_MAX ) {
                distances[index - 1] = distance + 1 ;
                q.push( {index - 1 , distance + 1 } ) ;
            }


            // move to next element 
            if (index != n - 1 && distances[index + 1] == INT_MAX) {
                distances[index + 1] = distance + 1 ;
                q.push( {index + 1 , distance + 1} ) ;
            }

            // if the element is prime , move to its multiple 
            if ( isprime[nums[index]] && used.find(nums[index]) == used.end()) {
                for(int j = nums[index] ; j <= maxvalue ; j += nums[index]) {
                    for(auto &i : locations[j]) {
                        if ( distances[i] != INT_MAX )
                            continue ;
                        distances[i] = distance + 1 ;
                        q.push({i , distance + 1}) ;
                    }
                }

                used.insert(nums[index]);
            }

        }


        return distances[n-1] ;
    }
};
```
