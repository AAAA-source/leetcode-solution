# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
Count how many LCT subsequences already exist, then evaluate the extra subsequences gained by inserting one letter.
A new L pairs with every existing CT, a new T pairs with every existing LC, and a new C pairs every L on its left with every T on its right.
# Approach
<!-- Describe your approach to solving the problem. -->
1.	Left-to-right pass: Tally total LC, total T, and existing LCT.
2.	Right-to-left pass: Tally total CT.
3.	Second left-to-right pass: Maintain prefix counts of L and T; at each cut compute prefixL × suffixT to find the best place to insert C.
4.	Take the maximum gain among inserting L, C, or T, and add it to the original count.
# Complexity
- Time complexity: $$O(n)$$ — three linear scans.
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

- Space complexity: $$O(1)$$ — only a fixed set of counters.
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

# Code
```python3 []
class Solution:
    def numOfSubsequences(self, s: str) -> int:
        cntL = cntLC = orig = totalT = 0
        for ch in s:
            if ch == 'L':
                cntL += 1
            elif ch == 'C':
                cntLC += cntL
            elif ch == 'T':
                orig += cntLC
                totalT += 1
        totalLC = cntLC

        cntT = totalCT = 0
        for ch in reversed(s):
            if ch == 'T':
                cntT += 1
            elif ch == 'C':
                totalCT += cntT

        prefixL = prefixT = bestC = 0
        for ch in s:
            bestC = max(bestC, prefixL * (totalT - prefixT))
            if ch == 'L':
                prefixL += 1
            elif ch == 'T':
                prefixT += 1
        bestC = max(bestC, prefixL * (totalT - prefixT))

        best_inc = max(totalCT, totalLC, bestC)
        return orig + best_inc
```
