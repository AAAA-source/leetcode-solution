# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
Each person who learns the secret goes through three stages:
1. **Waiting period** (first `delay - 1` days): cannot share yet.
2. **Sharing period** (from `delay` to `forget - 1` days): shares the secret with one new person each day.
3. **Forgetting period** (from `forget` days onward): completely forgets and can no longer share.

The task is to simulate how many new people learn the secret each day, while  updating the number of people who can share.
# Approach
<!-- Describe your approach to solving the problem. -->
1. Let `New_known[i]` represent the number of people who learn the secret on day `i`.  
   - Initialization: `New_known[1] = 1` since one person learns the secret on day 1.
2. Maintain a variable `share` to represent the number of people who are able to share the secret on day `i`.  
   - If `i - forget >= 1`, the people who learned the secret on day `i - forget` will forget it today, so we subtract them from `share`.  
   - If `i - delay >= 1`, the people who learned the secret on day `i - delay` start sharing today, so we add them to `share`.  
3. The number of new people who learn the secret on day `i` is exactly `share`, so set `New_known[i] = share`.  
4. At the end, the answer is the total number of people who still remember the secret, i.e., those who learned it within the last `forget - 1` days:  
   `sum(New_known[n - forget + 1 ... n])`.

# Complexity
- Time complexity: $$O(n)$$
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

- Space complexity: $$O(n)$$
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

# Code
```cpp []
class Solution {
public:
    int peopleAwareOfSecret(int n, int delay, int forget) {
        const int MOD = 1000000007;
        vector <int> New_known(n + 1, 0);

        New_known[1] = 1;
        int share = 0;
        for(int i = 2; i <= n; ++i){
            int stop = i - forget;
            if(stop >= 1){
                share -= New_known[stop];
                if(share < 0) share += MOD;
            }

            int start = i - delay;
            if(start >= 1) share = (share + New_known[start]) % MOD;
            New_known[i] = share;
            
        }
        long long ans = 0;
        for(int i = max(1, n - forget + 1); i <= n; ++i){
            ans = (ans + New_known[i]) % MOD;
        }
        return (int)ans;
    }
};
```
