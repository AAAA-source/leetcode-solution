# Intuition
We are asked to reduce every number in the range [l, r] to zero. In one operation, we pick two numbers a and b and replace them with floor(a/4) and floor(b/4).
Notice that each number requires a certain number of divisions by 4 before it becomes 0. For example:

Numbers 1..3 need 1 operation,

Numbers 4..15 need 2 operations,

Numbers 16..63 need 3 operations, and so on.

So, for a number x, the number of operations it needs equals ⌊log₄(x)⌋ + 1.

Since every operation reduces two numbers at the same time, the minimum operations required for a range is the total sum of all numbers’ requirements divided by 2, rounded up.

# Approach
For each query [l, r]:

Split the interval [l, r] into base-4 ranges: [1,3], [4,15], [16,63], [64,255], etc.

For each base-4 range, count how many numbers from [l, r] fall into it.

Multiply this count by the number of operations required for that level and accumulate.

After summing up the requirements, compute (sum + 1) / 2 because each operation processes two numbers simultaneously.

Add up the results for all queries.

# Complexity
- Time complexity:
O(q⋅logr)

- Space complexity:
O(1)

# Code
```cpp []
class Solution {
public:
    long long minOperations(vector<vector<int>>& queries) {
    long long res = 0;
    for (const auto &q : queries) {
        long long l = q[0], r = q[1], sum = 0, p = 0;
        for (long long p4 = 1; p4 <= r; p4 *= 4) { // 1, 4, 16, 64, ...
            int pl = max(l, p4), pr = min(r, p4 * 4 - 1);
            sum += max(0LL, ++p * (pr - pl + 1));
        }
        res += (sum + 1) / 2;
    }
    return res;
}
};
```
