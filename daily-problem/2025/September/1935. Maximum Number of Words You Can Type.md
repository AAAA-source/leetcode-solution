# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
Using C++ istreamstring object , then we can easy cut the text to words , then using a hash set to record the broken alphabets. When a word has no broken alphabet , then record it to answer.

# Complexity
- Time complexity: $O(n)$
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
We need O(n) time to traverse text. 

- Space complexity: $O(n)$
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
We need O(n) space to record the word in text.

# Code
```cpp []
class Solution {
public:
    int canBeTypedWords(string text, string brokenLetters) {
        unordered_set<char> broken ;
        for(auto &c : brokenLetters)
            broken.insert(c) ;


        istringstream iss(text) ;

        string s ;
        int ans = 0 ;
        while ( iss >> s ) {
            bool success = true ;
            for(auto &c : s) {
                if ( broken.find(c) != broken.end() ) {
                    success = false ;
                    break ;
                }
            }
            if (success)
                ans++ ;

        }

        return ans ;
    }   
};
```


# Optimization 
We can optimized the space complexity to O(1). That we just need to record the succes or not of now word in text without a string.
For convenience , we will add a space in the tail of text. 


# Code
```cpp []
class Solution {
public:
    int canBeTypedWords(string text, string brokenLetters) {
        vector<int> brokens(26) ;
        for(auto &c : brokenLetters)
            brokens[c - 'a'] = 1 ;

        int ans = 0 ;
        int index = 0 ;
        text += ' ' ;
        while ( index < text.size() ) {
            if ( text[index] == ' ' )
                ans++ ;
            else if ( brokens[text[index] - 'a'] ) {
                while ( index < text.size() && text[index] != ' ' )
                    index++ ;
            }
            index++ ;
        }


        return ans ;
    }
};
```
