# Approach 1
<!-- Describe your approach to solving the problem. -->
We sort the array and then fix two sides $(nums[i], nums[j])$.
For each such pair, we use binary search to find the first index $k$ where $nums[k] \ge nums[i] + nums[j]$.
All indices between $j+1$ and $k-1$ form valid triangles, since they satisfy the triangle inequality.

### Complexity
- Time complexity: $O(n^2\log n)$
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

- Space complexity: $O(1)$
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

### Code
```python3 []
class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        res = 0

        for i in range(n-2):
            for j in range(i+1, n-1):
                k = bisect_left(nums, nums[i]+nums[j])
                res += max(0, k - j - 1)

        return res
```
# Approach 2
<!-- Describe your approach to solving the problem. -->
Instead we use a two-pointer sweep on the remaining sides $(i, j)$ with $i < j < k$.
If $nums[i] + nums[j] > nums[k]$, then all pairs $(i, i+1, â€¦, j-1)$ with $nums[j]$ form valid triangles, so we add $j - i$ to the count and decrease $j$.
Otherwise, we increase $i$.

### Complexity
- Time complexity: $O(n^2)$, which is faster than Approach 1.
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

- Space complexity: $O(1)$
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

### Code
```python3 []
class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        res = 0

        for k in range(n-1, 1, -1):
            i, j = 0, k-1
            while i < j:
                if nums[i] + nums[j] > nums[k]:
                    res += j - i
                    j -= 1
                else:
                    i += 1
                    
        return res
```
