# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
After sorting the points by **x ascending** and then by **y descending**, we can scan each point `i` and look to the right for candidates `j > i`.  

For a pair `(i, j)` to be valid:
- `y[j] ≤ y[i]`, and  
- there is no point between `i` and `j` that lies inside (or on the border of) the rectangle defined by `i` and `j`.  

To enforce the second condition, we maintain a variable `max_y` while scanning. If `y[j] > max_y`, then `(i, j)` is the first point that creates a new "lower boundary" in the rectangle, so we count it. This guarantees no other points exist in the rectangle.

Sorting by `y` descending (when `x` values are equal) avoids breaking the monotonicity of `max_y`.
# Approach
<!-- Describe your approach to solving the problem. -->
1. Sort the points by `x` ascending and `y` descending:

2. Iterate through each point `i`:
   - Initialize `max_y = INT_MIN`
   - For all `j > i`, if `y[j] <= y[i]` and `y[j] > max_y` → count the pair and update `max_y = y[j]`.
3. Return the total count.
# Complexity
- Time complexity: $$O(n^2)$$
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

- Space complexity: $$O(1)$$
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

# Code
```cpp []
class Solution {
public:
    static bool cmp(const vector<int>& a, const vector<int>& b) {
        if (a[0] == b[0]) 
            return a[1] > b[1];
        return a[0] < b[0];
    }

    int numberOfPairs(vector<vector<int>>& points) {
        int n = points.size();
        int cnt = 0;
        sort(points.begin(), points.end(), cmp);
        for(int i = 0; i < n - 1; i++){
            int max_y = INT_MIN;
            for(int j = i + 1; j < n; j++){
                if(points[j][1] <= points[i][1] && points[j][1] > max_y){
                    cnt++;
                    max_y = points[j][1];  
                }
            }
        }
        return cnt;
    }
};
```
