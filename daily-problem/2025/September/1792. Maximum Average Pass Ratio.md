# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
By greedy intuition , every time we pick one extrastudent to the class which can gain the maximum ratio change.
ex. put one extrastudent to {1,2} can gain 2/3 - 1/2 ratio , but put this student to {3,5} can only gain 4/6 - 3/5 ratio.

So we just need to maintain the maximum ratio each time we gain , and put all extrastudents in. After that , compute the average ratio and output.

# Approach
<!-- Describe your approach to solving the problem. -->
We use a heap (priority queue) to maintain the maximum gain ratio at top. At the first , we store a array(vector) which is {passnumber, totalnumber , classid} inside. And the heap will call compare operator to compare the array(vector).

Each time we get the top element and update the ratio and students number, and put it back until there is no extrastudent.

# Complexity
- Time complexity: $O((n+k)logn)$
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
Since we need O(nlogn) time to create the heap , and O(klogn) time to distrubute the extrastudents.

- Space complexity: $O(n)$
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
We need O(n) space for the arrays.

# Code
```cpp []

struct Compare {
    bool operator()(const vector<int>& a, const vector<int>& b) const {
        // max-heap based on additional ratio 
        if ( (double)(a[0] + 1) / (a[1] + 1) - (double) a[0] / a[1] < 
            (double)(b[0] + 1) / (b[1] + 1) - (double) b[0] / b[1] ) 
            return true ;
        else 
            return false ;
    }
};

class Solution {
public:
    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {
        // using greedy approach : always assign extraStudent to the minimum ratio 

        // using a max-heap to maintain the update ratio change 
        priority_queue<vector<int> , vector<vector<int>> , Compare> pq ;
        // storing {pass students , total students , class number}
        
        // using an array to record the pass ratio of each class 
        vector<double> ratio( classes.size() ) ;

        for(int i = 0 ; i < classes.size() ; i++) {
            if ( classes[i][0] != classes[i][1] )
                pq.push( {classes[i][0] , classes[i][1] , i} ) ;
            ratio[i] = (double) classes[i][0] / classes[i][1] ;
        }

        while ( !pq.empty() && extraStudents > 0) {
            int classnumber = pq.top()[2] ;
            int passnumber = pq.top()[0] ;
            int totalnumber = pq.top()[1] ;
            //printf("now top is {%d , %d}\n" , passnumber , totalnumber) ;
            pq.pop() ;
            
            // add one extraStudent to this class 
            passnumber++ ;
            totalnumber++ ;
            extraStudents-- ;

            // update ratio array and push it to heap 
            ratio[classnumber] = (double) passnumber / totalnumber ;
            pq.push({passnumber , totalnumber , classnumber}) ;
        }

        // compute average ratio 
        double sum = 0.0 ;
        for(auto &r : ratio)
            sum += r ;

        return sum / ratio.size() ;
    }
};

```

For the approach with array(vector) in heap is a little bit slow. Since the passnumber and totalnumber we can alreay get them in classes array. We just need to store a pair in heap, which is {gain ratio , classid}. In this case , heap just need to compare pairs instead of arrays. So the speed will be faster.

# Code
```cpp []

class Solution {
public:
    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {
        // using greedy approach : always assign extraStudent to the minimum ratio 

        // using a max-heap to maintain the update ratio change 
        priority_queue<pair<double , int>> pq ;
        // storing {gain ratio , class id}
        
        // using an array to record the pass ratio of each class 
        vector<double> ratio( classes.size() ) ;

        for(int i = 0 ; i < classes.size() ; i++) {
            if ( classes[i][0] != classes[i][1] )
                pq.push( { (double)(classes[i][0] + 1) / (classes[i][1] + 1) -
                (double)classes[i][0] / classes[i][1] ,i} ) ;
            ratio[i] = (double) classes[i][0] / classes[i][1] ;
        }

        while ( !pq.empty() && extraStudents > 0) {
            int classid = pq.top().second ;
            int& passnumber = classes[classid][0] ;
            int& totalnumber = classes[classid][1] ;
            //printf("now top is {%d , %d}\n" , passnumber , totalnumber) ;
            pq.pop() ;
            
            // add one extraStudent to this class 
            passnumber++ ;
            totalnumber++ ;
            extraStudents-- ;

            // update ratio array and push it to heap 
            ratio[classid] = (double) passnumber / totalnumber ;
            pq.push({ (double) (passnumber + 1) / (totalnumber + 1) 
            - (double)passnumber / totalnumber ,classid}) ;
        }

        // compute average ratio 
        double sum = 0.0 ;
        for(auto &r : ratio)
            sum += r ;

        return sum / ratio.size() ;
    }
};

```
