# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
Look only at friend pairs without a common language. If everyone in those pairs learns the most frequent language among them, the number of people to teach is minimized.
# Approach
<!-- Describe your approach to solving the problem. -->
1. **Collect conflict pairs**: For each friendship, if the two users share no language, add the pair to bad_pairs.
2. **Count languages**: For every user in any conflict pair, count which languages they already know; pick the language with the highest count (best_lang).
3. 	**Compute answer**: teach = (# conflict users) â€“ (users who already know best_lang).
# Complexity
- Time complexity: **O(total language entries + friendships)**
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

- Space complexity: **O(n)** (for the language-count array)
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

# Code
```python3 []
class Solution:
    def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:
        bad_pairs = [
            (u, v) for u, v in friendships
            if not set(languages[u-1]) & set(languages[v-1])
        ]

        need_check = set()
        for u, v in bad_pairs:
            need_check.add(u)
            need_check.add(v)

        if not need_check:
            return 0

        lang_count = [0] * (n + 1)  # 1-indexed
        for user in need_check:
            for lang in languages[user-1]:
                lang_count[lang] += 1

        best = max(lang_count)
        return len(need_check) - best
```
