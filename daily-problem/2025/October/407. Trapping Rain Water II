# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
In a 2D height map, water can only be trapped if it is surrounded by taller barriers on all sides. The lowest boundary determines the maximum water level inside the region.

# Approach
<!-- Describe your approach to solving the problem. -->
We use a priority queue (min-heap) to simulate water filling the terrain. The algorithm works as follows:
1. Initialize boundaries: Push all boundary cells into a priority queue with their heights, and mark them as visited. These act as walls that can potentially trap water inward.
2. Process lowest boundary first: Pop the lowest-height cell from the queue. This guarantees we always expand inward from the current minimum boundary.
3. Check neighbors: For each unvisited neighbor, the trapped water is determined by the difference between the current boundary height and the neighbor's height (if positive).
4. If the neighbor is lower, water fills up to the boundary height.
Otherwise, no water is trapped, but the neighbor itself becomes part of the new boundary.
5. Update priority queue: Push the neighbor into the heap with the maximum of its original height and the current boundary height (because water raises its effective level).
6. Repeat until heap is empty.

This ensures water accumulation is computed correctly, just like simulating water filling valleys from the outside inward.


# Complexity
- Time complexity: $O(mn\log(mn))$
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

- Space complexity: $O(mn)$
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

# Code
```python3 []
class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -> int:
        m, n = len(heightMap), len(heightMap[0])
        pq = []
        vis = [[False] * n for _ in range(m)]
        
        for i in range(m):
            heappush(pq, (heightMap[i][0], i, 0))
            heappush(pq, (heightMap[i][n-1], i, n-1))
            vis[i][0] = True
            vis[i][n-1] = True
        for j in range(1, n-1):
            heappush(pq, (heightMap[0][j], 0, j))
            heappush(pq, (heightMap[m-1][j], m-1, j))
            vis[0][j] = True
            vis[m-1][j] = True
        
        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        res = 0
        
        while pq:
            h, i, j = heappop(pq)
            for di, dj in dirs:
                ni, nj = i+di, j+dj
                if 0 <= ni < m and 0 <= nj < n and not vis[ni][nj]:
                    res += max(0, h - heightMap[ni][nj])
                    heappush(pq, (max(h, heightMap[ni][nj]), ni, nj))
                    vis[ni][nj] = True
        
        return res
```
