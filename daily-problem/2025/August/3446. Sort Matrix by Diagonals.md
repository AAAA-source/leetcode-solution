# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
Sorting every diagonal independently , and then fill new value in the correct position !

# Approach
<!-- Describe your approach to solving the problem. -->
We start traverse from bottom-left side (n - 1 , 0) (because this diagonal only have one element , we skip this diagonal in code) , then traverse the whole diagonal. After that , sorting the elements in diagonal (which temporally stored in another array). Finally we just need to fill new value in every positions. 

For the top-right area , we start from (0 , 1) and end with (0 , n - 1) (there is only one element in this diagonal , so we will skip in code ) the only difference is that the sorting direction is reverse. 

# Complexity
- Time complexity: $O(n^2logn)$
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
We will traverse O(n) diagonals , and each diagonal takes O(nlogn) time to sorting and filling elements.

- Space complexity: $O(n)$
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
we need O(n) space to store elements

# Code
```cpp []
class Solution {
public:
    vector<vector<int>> sortMatrix(vector<vector<int>>& grid) {
        int n = grid.size() ;
        
        // start from (n - 2 , 0) , end with (0 , 0) diagonal
        for(int i = n - 2 ; i >= 0 ; i--) {
            vector<int> appear ; 
            int index = 0 ;
            while ( i + index < n ) {
                appear.push_back(grid[i+index][index]) ;
                index ++ ;
            }
            sort(appear.begin() , appear.end() , greater<int>() ) ;
            index = 0 ;
            while ( i + index < n ) {
                grid[i+index][index] = appear[index] ;
                index++ ;
            }

        }

        // start from (0 , 1) , end with (0 , n - 2)
        for(int j = 1 ; j <= n - 2; j++) {
            vector<int> appear ; 
            int index = 0 ;
            while ( j + index < n ) {
                appear.push_back(grid[index][j+index]) ;
                index++ ;
            }
            sort(appear.begin() , appear.end()) ;
            index = 0 ;
            while ( j + index < n ) {
                grid[index][j+index] = appear[index] ;
                index++ ;
            }

        }

        return grid ;
    }
};
```
