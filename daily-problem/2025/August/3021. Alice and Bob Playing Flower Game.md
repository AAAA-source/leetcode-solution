# Method 1: Counting Odd + Even Pairs
## Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
Alice wins when the total number of flowers is odd. That happens only if one number is odd and the other is even.

## Approach
<!-- Describe your approach to solving the problem. -->
Count how many odd and even numbers exist in [1..n] and [1..m]. Then compute odd(n)*even(m) + even(n)*odd(m).

# Method 2: Half of Total Pairs (Fast)
## Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
There are n*m total pairs. About half of them will have odd sums and half even sums. Therefore, Alice wins in exactly ⌊(n*m)/2⌋ cases.

## Approach
<!-- Describe your approach to solving the problem. -->
Simply compute (n*m)//2.

## Complexity
- Time complexity: O(1)
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

- Space complexity: O(1)
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

# Code
```python3 []
class Solution:
    def flowerGame(self, n: int, m: int) -> int:
        return (n * m) // 2
```


# 方法一：數「一奇一偶」的配對

## Intuition
Alice 想要贏，總花數必須是奇數。這只有在**一個數字是奇數、另一個是偶數**的時候會發生。

## Approach
先算出 1..n 和 1..m 裡各自有多少奇數和偶數，再計算「奇數 × 偶數」加上「偶數 × 奇數」，結果就是答案。

## 複雜度 (Complexity)
時間 O(1)，空間 O(1)。

# 方法二：一半的組合（快速）
## Intuition
總共有 n*m 種組合，其中大約一半會是奇數和，一半會是偶數和。因此 Alice 獲勝的情況就是 ⌊(n*m)/2⌋。

## Approach
直接計算 (n*m)//2 即可。

複雜度 (Complexity)
時間 O(1)，空間 O(1)。
